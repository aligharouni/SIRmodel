---
title: "SIR Model With Testing Flows and Isolation"
author: "Ali"
date: "15/08/2020"
output: html_document
# output: pdf_document
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Notes on other references: (1) [testing_flow.md](testing_flow.md)(I am using the notation in this doc)

# On Math and Weighting

## Objectives

- An exploration of simple mathematical/computational models of COVID-19 to gain insight into the effects of different levels of testing and isolation on $R_t$/growth rates. The goal is insight.



## Model and Definitions

### Assumptions
JD: Why are we assuming structurally that the test is perfectly specific? I guess it's better to put all of the boxes in and just sometimes assume that that $p_S=0$ 
- Assume there are 3 groups of individuals: $S$, $I$ and $R$.
- Each group splits into 4 subgroups to incorporate the testing mechanism, so overall the model framework has 12 compartments as follows. $S_u,$ $S_n$, $S_p$, $S_t$, $I_u$, $I_n$, $I_p$, $I_t$, $R_u$, $R_n$, $R_p$, $R_t$.
- Further, assume that (1) a perfectly specific test, i.e. no false positives, then $S_p$ and $S_t$ are always zero (2) there are two 'integrator' or 'accumulator' compartments, $N$ and $P$, to collect cumulative reported negative or positive tests. 
- There is a single FoI, $\Lambda$, all groups being exposed to all others. That is, where a susceptible individual move to does not depend on who infected it.

JD: Can we do a better job with capitalization? When $I$ in a subscript refers to the infected class, for example, it should be capitalized. Also, I guess it would be good to always use $P$ for positive (thus $N$ for negative), and then use $p$ for the probabilities. I guess the concern is that $p_S$ looks awkward? But I think clarity is more important.

### Parameters

```{r, out.width = "400px"}
knitr::include_graphics("../pix/sir_comp2.png")
```

- $\Lambda$: force of infection defined as $$\Lambda=\beta \frac{(I_u+\eta_w I_n+\eta_w I_p+ \eta_t I_t)}{N_0},$$ where $\beta$ is transmission rate, $\eta_w$ and $\eta_t$ are the isolation parameters for awaiting and reported individuals, respectively. We assume that $\eta_t<\eta_w$, i.e., the awaiting individuals for test results have a higher transmission probability than the reported individuals.
- $\omega$: the rate of *onward flow* from the awaiting positive compartment, $p$, to reported/tested compartment, $\rho$, or from awaiting negative compartment, $n$, back to $u$.  It has units of $1/time$.
- $\gamma$: recovery rate ($1/time$).
- $\rho$: per capita testing intensity across the whole population ($1/time$).
- $W$: weighted number of people available for tests, defined as $W = W_S S_u + W_I I_u + W_R R_u$.
- $\sigma$: scaling parameter for testing defined as $\sigma = \frac{\rho N_0}{W}$.
- $F_Z$: Weighted testing rate defined as $F_Z=\sigma W_Z$. That is, $F_S = \sigma W_S$, $F_I=\sigma W_I$ and $F_R = \sigma W_R$.

**Notes:** 

- The complicated part is the flow rate from $Z_u$ to $Z_n$, $Z_p$. The (total, not per capita) flow from $Z_u$ to $Z_n$ is $\rho (1-P_Z) F(W_Z) Z_u$, from $Z_u$ to $Z_p$ is $\rho P_Z F(W_Z) Z_u$. Where, $P_Z$ is the probability of positive test. Thus, $p_I$ represents the test accuracy. We assume $p_S=0$.

- On testing and scaling; at the simplest $F_Z=W_Z$.  

### On Testing

- Initial approach and singularity issue (not sure if I call it structural or numerical singularity?); 
$\sigma = \frac{\rho N_0}{W}$ was used initially. The issue was that the population in $S$ compartments appeared to blow up when the DFE is achieved ( in the simulation when time, $t>200$). This is  once the only untested people are susceptibles, the FoI will become $\Lambda=0$, testing rate $F_S=\rho N_0/S_u$. Thus, eq(1) of the model will be $d S_u/dt = - \rho N_0 + \omega S_n$ which is no longer dependent on $S_u$ and a linear rate of leaving the $S_u$ compartment.




### Model
The model is
\begin{align}
\label{mod:1}
1)\ d S_u/dt &= -\Lambda S_u - F_S S_u + \omega S_n \\
2)\ d S_n/dt &= -\Lambda S_n + F_S S_u - \omega S_n \\
3)\ d I_u/dt &= \Lambda S_u - F_I I_u + \omega I_n  - \gamma I_u  \\
4)\ d I_n/dt &= \Lambda S_n + (1-p_I) F_I I_u - \omega I_n -\gamma I_n \\
5)\ d I_p/dt &= p_I F_I I_u - \omega I_p -\gamma I_p \\
6)\ d I_t/dt &= \omega I_p - \gamma I_t  \\
7)\ d R_u/dt &= \gamma I_u - F_R R_u + \omega R_n \\
8)\ d R_n/dt &= \gamma I_n + (1-p_R) F_R R_u - \omega R_n  \\
9)\ d R_p/dt &= \gamma I_p + p_R F_R R_u  - \omega R_p  \\
10)\ d R_t/dt&= \gamma I_t + \omega R_p  \\
11)\ dN/dt &= \omega (S_n + I_n + R_n)   \\
12)\ dP/dt &= \omega(I_p + R_p).
\end{align}



```{r packages, message=FALSE}
library(deSolve)
library(ggplot2)
library(tidyr)
library(McMasterPandemic)
library(directlabels)
unpack <- McMasterPandemic::unpack

```

```{r, model formulation}
sir.model <- function(time,state,params){
    unpack(as.list(c(state,params)))
    ## Force of Infection  
    Lambda <- beta * (I_u + eta_w*(I_n+I_p) + eta_t*I_t)/N0
    ## scaling the weights
    W <- W_S*S_u+W_I*I_u+W_R*R_u
    sigma <- rho*N0/W
    F_S <- sigma*W_S
    F_I <- sigma*W_I
    F_R <- sigma*W_R

    dS_u.dt <- -Lambda*S_u - (1-p_S) * F_S * S_u + omega * S_n
    dS_n.dt <- -Lambda*S_n + (1-p_S) * F_S * S_u - omega * S_n 
    dI_u.dt <-  Lambda*S_u + omega * I_n - F_I * I_u - gamma * I_u
    dI_n.dt <-  Lambda*S_n + (1-p_I) * F_I * I_u  - omega * I_n - gamma * I_n
    dI_p.dt <-  p_I * F_I * I_u - omega * I_p - gamma * I_p 
    dI_t.dt <-  omega * I_p - gamma * I_t 
    dR_u.dt <- gamma * I_u + omega * R_n - F_R * R_u  
    dR_n.dt <- gamma * I_n + (1-p_R) * F_R * R_u - omega * R_n
    dR_p.dt <- gamma * I_p + p_R * F_R * R_u - omega * R_p
    dR_t.dt <- gamma * I_t + omega * R_p
    dN.dt <- omega * (S_n + I_n + R_n)
    dP.dt <- omega *(I_p + R_p)
    
    # return the rate of change
  dxdt <- c(dS_u.dt,dS_n.dt,dI_u.dt,dI_n.dt,dI_p.dt,dI_t.dt,dR_u.dt,dR_n.dt,dR_p.dt,dR_t.dt,dN.dt,dP.dt)
    ## }
    return(list(dxdt))
}

```

```{r model inputs, message=FALSE}
params <- c(N0=1000000, beta=.8,gamma=1/3, omega=0.25, rho=0.01, #0.8, 1/3
             W_S=1, W_I=1, W_R=1, #weights
             p_S=0, p_I=1, p_R=0.5, #prob of waiting for being tested positive
            eta_w=0.02, eta_t=0.01, #isolation parameter 
            s=2 #eta_w/eta_t
            )
class(params) <- "params_pansim"
state_init <- c(S_u=params[["N0"]], S_n=0,
                I_u=1,I_n=0,I_p=0,I_t=0,
                R_u=0,R_n=0,R_p=0,R_t=0,
                N=0,P=0)
d <- seq(0,200,by=0.1)
# Conditional stop for desolver
# rootfun <- function (time, state,params) { 
#   unpack(as.list(c(state,params)))
#   return(I_u - 1) }
```


```{r DFE, message=FALSE}
# DFE; numerical approach
library(rootSolve)
DFE <- function(S,params){
  S_u <- S[1]
  S_n <- S[2]
  I_u <-0
  R_u <-0
  unpack(as.list(params))
  W <- W_S*S_u+W_I*I_u+W_R*R_u
  sigma <- rho*N0/W
  F_S <- sigma*W_S
 
 return(c(eq1=S_u+S_n-N0,
          eq2=-F_S*S_u+omega*S_n))
}

roots_dfe <- multiroot(DFE, c(1, 1), parms = params, positive = T)
roots_dfe$root

# DFE; analytic approach
Sn_dfe <-function(params){
  unpack(as.list(params))
  return((rho*(1-p_S)*N0)/omega)
  }

Su_dfe<- params[["N0"]]-Sn_dfe(params)

state_dfe <- c(S_u=Su_dfe, S_n=Sn_dfe(params),
                I_u=0,I_n=0,I_p=0,I_t=0,
                R_u=0,R_n=0,R_p=0,R_t=0,
                N=0,P=0)
# check:
all.equal(c(state_dfe[["S_u"]],state_dfe[["S_n"]]),roots_dfe$root)
```

Test gradient
```{r}
g1 <- sir.model(time=0,state=state_init, params=params)
all.equal(sum(g1[[1]]),0)
```


```{r model_run, message=FALSE}
out <- as.data.frame(
  ode(
    func=sir.model,
    y=state_init,
    times= d, 
    parms=update(params,beta=2)
    # atol = 1e+1, rtol = 1e+1
    # rootfun = rootfun,
    # method="lsodar"
  )
)

out2 <- out %>%
  pivot_longer(c(S_u,S_n,I_u,I_n,I_p,I_t, R_u,R_n,R_p,R_t), names_to = "compartment", values_to = "value")
```


```{r plot_run1, warning=FALSE}
gg1 <- (ggplot(data=out2, aes(x=time,y=value,col=compartment))
    + geom_line()
    + scale_y_log10(limits=c(0.1,params[["N0"]]))
##    + scale_x_continuous(limits=c(0,240))
)
direct.label(gg1,"last.bumpup")
```

```{r run2, message=FALSE}
d_long <- seq(0,300,by=0.1)
## capturing badly behaved integrator warning messages
cc <- capture.output(
    out_long <- as.data.frame(
        ode(
    func=sir.model,
    y=state_init,
    times= d_long, 
    parms=update(params,beta=2)
    # rootfun = rootfun,
    # method="lsodar"
  )
  ))
out_long2 <- out_long %>%
    pivot_longer(c(S_u,S_n,I_u,I_n,I_p,I_t, R_u,R_n,R_p,R_t),
                 names_to = "compartment", values_to = "value")

```

```{r plot_long, warning=FALSE}
direct.label(gg1 %+% out_long2,"last.bumpup")
```

### Steady States

The Disease-Free Equilibrium, namely $E_1$, for the above SIR model is given by the solution of the following system:
$S_u+S_n=N0$ and $F_S S_u-\omega S_n=0$. The DFE is

$S_n^*= \frac{\rho}{\omega} N_0, S_u^*= N_0-S_n^*$, and $I_j=R_j=0 \ \forall j$.

### Basic Reproduction Number

The next generation matrix, $G = F V^{-1}$, is in the lower triangular form with $F$ and $G$ as follows.

$$R_0= (A \times S_u^* + B \times S_n^*) \times C,$$ where
$A=\gamma(\omega+\gamma) + (\gamma \eta_w + \omega \eta_t p_I) F_I$,
$B=\big(\omega+(F_I+\gamma)\eta_w\big) \gamma+\frac{(\eta_w \gamma+ \eta_t\omega) \omega p_I F_I }{\omega+\gamma}$ and 
$C=\frac{\beta/\gamma}{N_0 (\gamma(\omega+\gamma)+F_I(\gamma+\omega p_I))}$.

\begin{equation}\label{FV}
F= \beta/N_0 \left[ \begin {array}{cccc} 
S_u&\eta_w\,S_u&\eta_w\,S_u&\eta_t\,S_u\\
S_n&\eta_w\,S_n&\eta_w\,S_n&\eta_t\,S_n\\ 
0&0&0&0\\
0&0&0&0
 \end {array} \right],
 V=
 \left[ \begin {array}{cccc}  
F_I+\gamma&-\omega&0&0\\
-(1-p_I)F_I&\omega+\gamma&0&0\\
-p_I F_I&0&\omega+\gamma&0\\
0&0&-\omega&\gamma
\end {array} \right],
\end{equation}

\begin{equation}
G = \left[ \begin {array}{cc}
G_{11}&G_{12}\\
0&0
\end {array} \right], \text{ where } \\
G_{11} =C
\left[\begin {array}{cc}
A\,S_u & B\,S_u\\
A\,S_n & B\,S_n
\end {array}\right],
\end{equation}

The Eigenvalues of $G_{11}$, are 0 and $R_0$.
```{r R0}
F_I <- function(params){
   # Returns F_I at DFE 
  unpack(as.list(params))
  Sn<- Sn_dfe(params)
  Su<- N0-Sn
  sigma <- rho*N0/(W_S*Su) #at DFE 
  return(sigma*W_I)
}

 # just a test
  F_I(params=update(params,rho=0))
  
R0<-function(params){
    unpack(as.list(params))
    Sn <- Sn_dfe(params)
    Su <- N0-Sn
    # print(c(Su_dfe,Sn_dfe,Su_dfe+Sn_dfe))
    Fi <- F_I(params) #at DFE
    A <-gamma*(omega+gamma+eta_w*Fi) + omega*eta_t*p_I*Fi
    B <-(omega+eta_w*(Fi+gamma))*gamma+(eta_w*gamma+eta_t*omega)*(omega*p_I*Fi)/(omega+gamma)
    C <- beta/(N0*gamma*(gamma*(omega+gamma)+Fi*(gamma+omega*p_I)))
    return((A*Su+B*Sn)*C)
}

# R0 expression with eta_w/eta_t factored
R02<-function(params){
    unpack(as.list(params))
    Sn<- Sn_dfe(params)
    Su<- N0-Sn
    F_I <-F_I(params)  #at DFE
    
    A2 <- gamma*(p_I*F_I*omega*Sn+(omega+gamma)*(gamma*Sn+F_I*N0))
    B2 <- p_I*F_I*omega*(gamma*Su+omega*N0)
    D <- gamma*(omega+gamma)*(gamma*Su+omega*N0)
    C2 <- beta/((N0*gamma*(gamma*(omega+gamma)+F_I*(gamma+omega*p_I)))*(omega+gamma))
    # s <- eta_w/eta_t
    return((eta_t*(s*A2+B2)+D)*C2)
}

# R0<1:
R0(params=params)
# R0>1:
R0(params=update(params,beta=2))

# check
all.equal(R0(params=params),R02(params=params))
```

Can we recover $R_0=\beta/\gamma$ of the simple SIR? -yes
```{r checkings}
# checking if simple R_0 for SIR can be recovered?
# Case #1: rho=0
all.equal(R0(params=update(params,rho=0)), params[["beta"]]/params[["gamma"]])
# Case #2: 
all.equal(R0(params=update(params,eta_t=1,eta_w=1)), params[["beta"]]/params[["gamma"]])
```

### Contour plot of $R_0=1$ and interpretations approache 1
```{r contour_R0_1, message=FALSE,warning=FALSE }
n_out <- 5 ## facets (rows/cols)
n_in <- 41 ## grid N within facets
 # specify the ranges
 beta  <- 0.339  ## set beta high enough to allow R0>1 in worst case
 eta_w <- seq(0,1, length.out=n_out)
 eta_t <- seq(0,1, length.out=n_out) #0.001 to 0.5 
 rho     <- seq(0,0.01, length.out=n_in)
 omega <- seq(0.1,2 , length.out=n_in) #note omega must be > rho, was 0.011
 W_S <- 1 #choose 0.3 for TTI testing plan and 1 for the random testing.
 

 df1 <- expand.grid(N0=params[["N0"]],beta=beta,gamma=params[["gamma"]],omega=omega,rho=rho,
                    W_S=W_S,W_I=params[["W_I"]],W_R=params[["W_R"]],
                    p_S=params[["p_S"]],p_I=params[["p_I"]],p_R=params[["p_R"]],
                    eta_w=eta_w,eta_t=eta_t,s=params[["s"]])
 
# Need to be corrected: in F_I, state_dfe should be changed according to the df1!
df2<- data.frame(df1,R0=apply(df1,1,function(params_in)R0(params=params_in)),
                      Fi= apply(df1,1,function(params_in)F_I(params=params_in)))
                                         
which(df2[]<0)
```

```{r}
## hacked (not very robustly) to chain label_both() and label_parsed() ...
label_special <- function (labels, multi_line=FALSE, sep = "== ") {
    value <- ggplot2:::label_value(labels, multi_line = multi_line)
    variable <- ggplot2:::label_variable(labels, multi_line = multi_line)
    variable[[1]] <- gsub("_(.)$","[\\1]",variable[[1]])
    ## not using multiple faceting variables on each margin, so forget paste
    out <- Map(paste, variable, value, sep = sep)
    out[[1]] <- lapply(out[[1]], function(expr) c(parse(text=expr)))
    out
}
```

```{r show_contours_1, width=24,height=24,message=FALSE,warning=FALSE}
p1 <- ggplot(df2,aes(x=omega,y=rho,z=R0))+ theme_bw() +
    theme(panel.spacing=grid::unit(0,"lines"))
p1_temp <- (p1
    + geom_contour_filled(breaks=pretty(unique(df2$R0),5),
                          alpha=0.5) ## breaks=0.2)
    + geom_contour(breaks=1,alpha=0.5,colour="black")
    + facet_grid(eta_w~eta_t, labeller=label_special)
    + scale_x_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_y_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_fill_viridis_d(name=parse(text="R[0]"))
    + ggtitle("W[S]=0.3, W[I]=W[R]=1")
)
p1_temp
# filename = "R0contour_TTI.png"
# filename = "R0contour_random.png"
ggsave(p1_temp,filename = "R0contour_TTI.png" , path="../pix/")
```

### Contour plot of $R_0=1$ and interpretations approache 2, parametrization $s=\eta_w/\eta_t$

```{r contour_R0_2, message=FALSE,warning=FALSE }
 # specify the ranges
beta  <- 0.339  ## set beta high enough to allow R0>1 in worst case 
rho     <- seq(0,0.01, length.out=n_in)
omega <- seq(0.1,2 , length.out=n_in) #note omega must be > rho, 
eta_t <- seq(0.001,0.1, length.out=n_out)
s <- seq(1,10,length.out=n_out) 

 df11 <- expand.grid(N0=params[["N0"]],beta=beta,gamma=params[["gamma"]],omega=omega,rho=rho,
                    W_S=W_S,W_I=params[["W_I"]],W_R=params[["W_R"]],
                    p_S=params[["p_S"]],p_I=params[["p_I"]],p_R=params[["p_R"]],
                    eta_w=params[["eta_w"]],eta_t=eta_t,s=s)

df22<- data.frame(df11,R0=apply(df11,1,function(params_in)R02(params=params_in)),
                      Fi= apply(df11,1,function(params_in)F_I(params=params_in)),
                       Sn=apply(df11,1,function(params_in)Sn_dfe(params = params_in)))
```

```{r show_contours_2, width=24,height=24,message=FALSE,warning=FALSE}
p11 <- ggplot(df22,aes(x=omega,y=rho,z=R0))+ theme_bw() +
    theme(panel.spacing=grid::unit(0,"lines"))
p2_temp <- (p11
    + geom_contour_filled(breaks=pretty(unique(df22$R0),5),
                          alpha=0.5) ## breaks=0.2)
    + geom_contour(breaks=1,alpha=0.5,colour="black")
    + facet_grid(s~eta_t, labeller=label_special)
    + scale_x_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_y_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_fill_viridis_d(name=parse(text="R[0]"))
    + ggtitle("W[S]=1, W[I]=W[R]=1")
)
p2_temp
ggsave(p2_temp,filename = "R0contour_random_s.png" , path="../pix/")
```

Let call the $F_I$ the critical testing rate in the above plot.

**Propositions**

1. $\partial{R_0}/\partial{\eta_t} \geq 0$ and $\partial{R_0}/\partial{\eta_w} \geq 0$.
That is, the lower isolation the higher $R_0$. Note that perfect isolation occurs at $\eta_w = 0$. 
2. $\partial{R_0}/\partial{\rho} \leq 0$; this is concluded from the Taylor expansion of $R_0$ around $\rho=0$ which is
$R_0 \approx \beta/\gamma + \frac{\beta \rho}{\omega (\omega+\gamma) \gamma^2 W_S} \Big(\gamma(\eta_w-1)(\gamma W_S+\omega W_I) + (\eta_t -1)P_iW_i \omega^2 \Big) + \mathcal{O}(\rho^2)$.
3. Based on the above Taylor expansion around $\rho=0$,
$$\partial{R_0}/\partial{\omega}=  \frac{-\beta \rho}{\gamma W_S\omega^2 (\gamma+\omega)^2}  (a \omega^2 + b \omega + c), $$
where $a=(\eta_w-1)W_I-(\eta_t-1)P_I W_I = ((s-p_I)\eta_t + (p_I-1)) W_I$, $b=2(\eta_w-1)\gamma W_S$ and $c=(\eta_w-1)\gamma^2 W_S$.
Given that $\eta_t\leq \eta_w$, it is inferred that $a\geq 0$, $b\leq 0$ and $c \leq 0$.
Let $\omega_1<0$ and $\omega_2>0$ be the roots of the quadratic expression in $\partial{R_0}/\partial{\omega}$. Thus, $\partial{R_0}/\partial{\omega}>0$ for $0<\omega<\omega_2$ and  $\partial{R_0}/\partial{\omega}<0$ for $\omega>\omega_2$.

In general, $a \geq 0$ is not true. $$a \geq 0 \iff (s-p_I) \eta_t \geq (1-p_I),$$ where $s=\frac{\eta_w}{\eta_t} \geq 1$. As an example, in the case of a very accurate testing regime,  i.e., $P_I=1$, $a \geq 0$ is achieved. 

**Perfect isolation**; When $\eta_w=0$ and consequently $\eta_t=0$. This leads to $a \leq 0$, $b<0$, $c<0$, thus $\partial{R_0}/\partial{\omega} \geq 0$. Intuitively, returning the test results back to the awaiting individuals while they are in a perfect isolation results in an increase of $R_0$.

**Insights from the R0-contour plots**

1. TTI requires lower testing rate than random testing to achieve $R_0=1$.

2. When random testing regime is applied, $W_S=W_I=W_R$,

(i) in the case of perfect isolation of the reported individuals, $\eta_t=0$, the followings are inferred (see the first few columns of the panel plot); 
 - variations of the $\eta_w$ has a negligible effect on the critical testing.
 - for low $\omega$, $R_0$ increases as $\omega$ increases but saturates. This means that when the reporting process is very very slow, increasing the speed of the reporting causes higher $R_0$. Maybe because more people will move to $I_u$ [?, not very sure here.]
 (ii) in case of the non-perfect isolation (see the last column), when $\eta_w$ increases (more awaiting people follow the isolation rules) faster reporting reduces $R_0$.  
Note that it is sensible to expect that $\partial{R_0}/\partial{\omega}<0$. Here we showed that this can be less true. 

3. When TTI regime is applied,



```{r  chnages of R0 wrt omega,message=FALSE,warning=FALSE }
R0_omega <- function(params){
  unpack(as.list(params))
         # a <- (eta_w-1)*W_I-(eta_t-1)*p_I*W_I
         a <- ((s-p_I)*eta_t + (p_I-1))*W_I  #involving s
         b <- 2*(eta_w-1)*gamma*W_S
         c <- b*gamma/2
         
         d <- (-beta*rho)/(gamma*W_S*omega^2*(gamma+omega)^2)*(a*omega^2 + b*omega + c)
         return(d)
}

R0_omega(params)
  
```

```{r }
 # specify the ranges
if(F){
beta  <- 0.5  ## set beta 
gamma <- seq(0.1,0.5, length.out=n_out)
p_I <- 0.9

# eta_w <- seq(0,1, length.out=n_out)
eta_t <- seq(0.001,1, length.out=n_out)
s <- seq(1,2,length.out=n_out)

rho <- seq(0,0.01, length.out=n_in)
omega <- seq(0.011,2 , length.out=n_in) #note omega must be > rho, was 0.011

W_S <- 1/100
W_I <- 1/3
W_R <- 1/3

 df3_1 <- expand.grid(N0=params[["N0"]],beta=beta,gamma=gamma,omega=omega,rho=rho,
                    W_S=W_S,W_I=W_I,W_R=W_R,
                    p_S=params[["p_S"]],p_I=p_I,p_R=params[["p_R"]],
                    eta_w=params[["eta_w"]],eta_t=eta_t,s=s)

df3_2 <- data.frame(df3_1,R0=apply(df3_1,1,function(params_in)R02(params=params_in)),
                      R0_omega= apply(df3_1,1,function(params_in)R0_omega(params=params_in))
                       )
}
```

```{r show_contours_3, width=24,height=24,message=FALSE,warning=FALSE}
if(F){
p3 <- ggplot(df3_2,aes(x=omega,y=gamma,z=R0_omega))+ theme_bw() +
    theme(panel.spacing=grid::unit(0,"lines"))
(p3
    + geom_contour_filled(breaks=pretty(unique(df3_2$R0_omega),5),
                          alpha=0.5) ## breaks=0.2)
    + geom_contour(breaks=0,alpha=0.5,colour="black")
    + facet_grid(s~eta_t, labeller=label_special)
    + scale_x_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_y_continuous(expand=expansion(c(0,0)), n.breaks=3)
    + scale_fill_viridis_d(name=parse(text="dR[0]"))
)
}
```

