\documentclass{article}

\begin{document}
By Ali Gharouni,
<<date,echo=F>>=
Sys.time()
@
This is my a test for MacPan package in 2 steps:
- step 1: simulate a simple SIR model and recover the results by specifying the parameters of MacPan.
- step 2: Read COVID19-Canada data from Mike's repo, estimate the transmision rate beta(t) and do projection.


\section{Install and Play}

<<install the package, echo=T  >>=
# install remotes package if necessary:
while (!require(remotes)) {
    install.packages("remotes")
}
## install development version of bbmle:
if (!require("bbmle") || packageVersion("bbmle") < "1.0.23.5") {
    remotes::install_github("bbolker/bbmle")
}
## install the target package and all its dependencies:
remotes::install_github("bbolker/McMasterPandemic",
                        dependencies = TRUE,
                        build_vignettes = TRUE
)
library(McMasterPandemic)
library(ggplot2); theme_set(theme_bw())
library(cowplot)

library(directlabels)
library(zoo)
library(tidyverse)
@


<<6: MacPan Params , echo=T>>=
params <- read_params("ICU1.csv")

knitr::kable(round(t(summary(params)),2))
knitr::kable(round(t(get_R0(params, components=TRUE)),2)) 
@

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Step 1, SIR and MacPan}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Ali:SIR , echo=T>>=
# A simple SIR model
library(deSolve)
unpack <- McMasterPandemic::unpack

sir.mod <- function(time,state,params){
    unpack(as.list(c(state,params)))
    dS.dt <- -beta*S*I/N0
    dI.dt <-  beta*S*I/N0-gamma*I
    dR.dt <-  gamma*I
    # return the rate of change
    dxdt <- c(dS.dt,dI.dt,dR.dt)
    return(list(dxdt))
}
sir.params <- c(N0=10^6, beta=0.5,gamma=1/7)
class(sir.params) <- "params_pansim"
# Set the initial state
sir.state_init <- c(S=sir.params[["N0"]], 
                I=1,
                R=0)
##set the number of days for SIR simulation as simulation time of MacPan
startdate <- as.Date("01-03-2020")
enddate <- as.Date("01-09-2020")
d <- seq(0,as.numeric(enddate-startdate),by=1) 

sir.R0 <- sir.params[["beta"]]/sir.params[["gamma"]]

sir.out <- as.data.frame(
  ode(
    func=sir.mod,
    y=sir.state_init,
    times= d, 
    parms=update(sir.params)
    ))

sir.out2 <- sir.out %>%
  pivot_longer(c(S,I,R), names_to = "compartment", values_to = "value")

gg1 <- (ggplot(data=sir.out2, aes(x=time,y=value,col=compartment))
    + geom_line()
    # + scale_y_log10(limits=c(0.1,sir.params[["N0"]]))
)
direct.label(gg1,"last.bumpup")

@


<<Try MacPan to recover the SIR result, echo=T>>=
## update MacPan's params according to the SIR params
##
big_rate <- 20
params <- update(params, c(beta0=sir.params[["beta"]],
                           alpha=0, ## no asymptomatic
                           sigma=big_rate, ## very short latent period
                           ## would like this to -> Inf but can't
                           gamma_a=0,
                           mu=1,  ## all cases mild
                           gamma_m=sir.params[["gamma"]],
                           gamma_s=0,
                           ## try to skip presymptomatic period
                           gamma_p=big_rate
                           ))

pp <- params
## pp <- fix_pars(params, target = c(R0 = sir.R0)) #not sure if I need to update Gbar=6?
state <- make_state(params=pp)
state[] <- 0
state[["S"]] <- 1e6
state[["Im"]] <- 1

summary(pp)
sim0 <- run_sim(pp,state,
                start_date=startdate,
                end_date=enddate,
                use_ode=TRUE)

gg0 <- (ggplot(sim0,aes(x=date))
+ geom_point(aes(y=incidence))
)
print(gg0)

# combining the SIR and MacPan results also calculating incidences fr the SIR model
sim_combined <- sim0 %>% mutate(sir.S=sir.out[["S"]],
                                sir.I=sir.out[["I"]],
                                sir.S=sir.out[["R"]],
                                sir.incidence=sir.params[["beta"]]*sir.out[["S"]]*sir.out[["I"]])

gg01 <- (ggplot(sim_combined,aes(x=date))
+ geom_point(aes(y=I))
+ geom_line(aes(y=sir.I), color='red')
)
print(gg01)
print(gg01 + scale_y_log10())

@

% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Step 2, Data and MacPan}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

<<Read Data from Mike's repo, echo=T>>=
library(McMasterPandemic)
library(readr)
library(dplyr)
library(ggplot2); theme_set(theme_bw())
library(directlabels)

covid_url <- "https://raw.githubusercontent.com/wzmli/COVID19-Canada/master/git_push/clean.Rout.csv"
df_covid <- read_csv(covid_url)

## BMB: the fit was using *cumulative* cases before, 
## Ali I used confirmed_positive before
plot_pos_prov <- ggplot(df_covid,aes(x=Date,y=newConfirmations,col=Province))+
  geom_point()

direct.label(plot_pos_prov,"last.bumpup")

# Assume we are just looking at Ontario's epidemic case:

startdate <- as.Date("2020-12-11")
enddate <- as.Date("2021-01-14")
## BMB: if we use the original, short time series
##   Error in stats::filter(i, kern, sides = 1) : 
##     'filter' is longer than time series

df_covid_on <- (df_covid 
                %>% filter(Province =="ON", Date >= startdate) # Ontario
                %>% mutate(value= round(newConfirmations), var= "report", date=Date)
                %>% select(date, value, var)
                %>% na.omit()
)
## BMB: check length, beginning
nrow(df_covid_on)
head(df_covid_on,1)

## beta0 (and E0) the only parameter we're going to optimize:
params <- read_params("ICU1.csv")
## adjust to ON pop size, approx starting value:
## about 1800 cases reported
## adjust ascertainment rate (fraction of cases reported) to 1/3
## (was 0.1, which was reasonable at beginning of epidemic)
## (will just rescale results)
## so 1800 cases -> prevalence of approx 3*1800
## initial conditions automatically spread E0 over the eigenvector
params <- update(params, N=15e6,E0=3*1800, c_prop=1/3)

## set up optimization parameters
opt_pars <- get_opt_pars(params, vars="report")

params1obs <- update(params, obs_disp=20)

## document: bounds for DE optimization???

plot(run_sim(
    params = params1obs,
    start_date=startdate,
    end_date=enddate),
    keep_states="report", log=TRUE)

## fit beta0 based on the report data:
fitted.mod <- calibrate(
  data = df_covid_on
  , start_date = startdate
  ## skip breaks that are present by default:
, time_args = list(break_dates = NULL)
  , base_params = params1obs
, opt_pars = opt_pars
 , debug_plot = TRUE # instructive plotting during optimization
)

## plot the resulting fit
plot(fitted.mod,data=df_covid_on) # all
plot(fitted.mod,data=df_covid_on, # just report data
     predict_args=list(keep_vars=c("report")))

coef(fitted.mod) ## output all fitted params
coef(fitted.mod,"fitted") ##output just beta0
## Note that that the value of \code{beta0} used for the simulation was 1

## FIXME in macpan: check for correct structure in opt_pars
## check length of time series?
## FIXME: shouldn't need to specify time_args ...

# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
## Forecasting
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
## Here, an example involving changing the transmission rate ($\beta$) in the future due to lockdown

pp <- coef(fitted.mod, "all") # all the fitted params in the form of ICU1
# pp <- fix_pars(params, target = c(R0 = 1.3, Gbar=6)) # or you could specify your R0 and Gbar
state <- make_state(params=pp)

startdate <- as.Date("2020-12-11")
enddate <- as.Date("2021-01-30")

sim0 <- run_sim(pp,state,start_date=startdate,end_date=enddate)
gg0 <- (ggplot(sim0,aes(x=date))
	+ geom_point(aes(y=report))
)
print(gg0)

## Question: the runsim gives reported cases starrting from 2465 cases and grows, it doesn't match the reported data! I think I am missing some scaling here?  


## Goal: to forcast after the date of lockdown
## We want a dataframe that includes the time varying relative $\beta$ at relative $\beta$ to drop by a factor of 2 (linearly) between 14 Jan 2021 on at each saved time point.
lockdown <- as.Date("2021-01-14")

time_pars <- data.frame(Date=as.Date(startdate:enddate)
	, Symbol="beta0"
	, Relative_value= pp[["beta0"]] ## Here I am using the caliberated Beta0
)
	# , stringsAsFactors=FALSE)

time_pars2 <- 
    data.frame(Date=as.Date(startdate:enddate)
             , Symbol="beta0"
             , Relative_value = 
                   c(rep(pp[["beta0"]], length(startdate:lockdown)-1)
                   , seq(pp[["beta0"]],pp[["beta0"]]-0.1,length.out = length(lockdown:enddate))
                     )
               )
print(time_pars2)

sim0_t_reduce <- update(sim0, params_timevar=time_pars2)
gg_rel_beta <- (ggplot(time_pars, aes(x=Date))
	+ geom_point(aes(y=Relative_value))
	+ geom_point(data=time_pars2, aes(x=Date, y=Relative_value), color="red")
)
print(gg_rel_beta)
# We can now look at the relative value of $\beta$ in each scenario, and the corresponding forecasted epidemic curves.


print(gg0
		+ geom_point(data=sim0_t_reduce, aes(x=date,y=incidence), color="red")
)

## Question: How to add confidence Int?

@




\end{document}
